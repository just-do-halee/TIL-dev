###### _by just-do-halee_

# _Today I learned_

## 2022-9-20

<br>

- OS::Basic

  - ::`Stack`

    - 프로세스 메모리 내 Stack 영역이란, 진행 프로그램 코드 내에서 각 호출되는 함수 내에 생성되는 변수 및 여러 주소들을 임시로 보관하는 역할을 한다.

    - 함수의 `매개변수`, 호출 완료 후 되돌아갈 `반환값의 주소`, 함수 내 선언된 `지역 변수` 등이 저장된다.

    - 이렇게 함수 호출 후 보관하는 함수의 호출 정보를 `Stack Frame`이라고 한다.

    - 모든 함수들은 호출될 시 `새로운 Stack Frame`으로서 `Process(or Thread) Stack 내에 차곡차곡 쌓이게 되며 할당`된 후에, 호출이 완료된 뒤 값을 반환할 시 `쌓아두었던 Stack Frame을 그제야 할당해제`한다.

    - Stack의 할당은 `High Memory로부터 Low Memory로` 순차적으로 진행된다.

    - Stack에 할당된 변수는 그 변수를 할당한 `호출된 함수`만이 접근 가능하다.

    - Stack에 쌓이는 변수들의 크기(Size)는 전부 컴파일 시간(Compile Time) 때 미리 알 수 있어야 한다. 함수 호출 시 그만큼을 미리 한꺼번에 전부 할당한 후에, 읽어내리면서 변수를 그 Capacity 내에 Push하기 때문이다. 전부 읽어내린 후, 반환 시에 할당한 만큼을 다시 할당해제한다.

    - `전체 Stack 또한 한정된 크기(Size)를 지닌다.` 머신 아키텍처(Machine Architecture), 운영체제(Operating System), 컴파일러(Compiler) 등에 의해 미리 정해진다.

    - 한정된 Stack Size를 초과할 경우, Stack Overflow Error를 발생하며 프로그램은 강제 종료된다.

  - ::`Heap`

    - 프로세스 메모리 내 Heap 영역이란, Stack과는 달리 자동화되어 관리되지 않는 메모리 영역을 말한다. 수작업으로 메모리를 할당해 주고, 할당했으면 수작업으로 할당해제해주어야 한다.

    - 할당한 메모리를 할당해제하지 않고 있으면 `메모리 누수(Leak)`을 일으킨다.

    - Stack(2mb~10mb..)과는 달리 `크기(Size) 제한이 없기에 얼마든지 메모리를 이용해 프로그램 데이터를 보관`할 수 있다. 단, 시스템의 물적 자원의 크기만이 제한 사항(RAM Capacity..etc)을 갖는다.

    - 한번 Heap에 저장된 데이터는 `어느 곳에 있든 어떤 함수이든 같은 프로세스 권한 내에 존재한다면 접근 가능`하다.

    - Heap 할당은 `값비싸다.` Stack은 이미 정돈된 공간에서 정해진 만큼을 사용하도록 돼 있기에 보다 값싸다.

    - 프로그램이 Heap에 `할당 및 재할당을 여러 번에 걸쳐 진행하게 된다면, 결국 그 Heap은 파편화될 것이기에 가능한 한 사용을 자제해야 한다.` 메모리가 파편화된다면, 다음번 새 할당 시 필요한 공간을 충분히 효과적으로 찾을 수가 없기 때문이다.

      ```rust
      let heap_num = Box::new(7u32);
      // Heap에 4 bytes만큼을 할당한 후, 값 7을 넣는다.
      ```

      - 이 경우 heap_num에는 값 7이 직접 저장되는 것이 아닌, 4 bytes만큼 할당된 Heap 메모리 위치 주소가 저장된다.

        ex:) heap_num = `0xf578bb60` (address)

        heap_num은 이때 메모리 주소를 가리키는 Pointer라고 부를 수 있으며 그로부터 `내부 값 숫자 7를 가져오고 싶다면, Derefernce(\*) 지시자를 사용`해야 한다.

      - 만일 한 프로세스 내에서 Heap에 메모리를 할당했음에도 사용 이후 해제하는 것을 잊게 된다면, Stack 상에서는 이미 관련된 코드들이 사라진 상태임에도, Heap 상에는 그대로 `Using` 상태로서 할당된 메모리가 남아 있어 `프로세스가 종료 시까지` 그 어떤 다른 프로세스는 물론 무엇도 사용할 수 없는 장애물 마냥 자리잡게 된다. 이를 `메모리 누수(Leak)`이라고 한다.

      - `프로세스가 종료`되면, 프로세스 권한이 있던 모든 Heap 메모리는 `자동 할당해제`된다.

      - ::참고::

        - `Pointer의 크기(Size)는 컴파일 시간(Compile Time) 때 미리 정해진다.` CPU 아키텍쳐에 따라 달라지지만, 보통 `32비트` 또는 `64비트로` 정해져 있다. _(= 'usize' in Rust)_

<br>

- Network::History

  - 1836년, 사무엘 모르스가 `전신`을 개발.
  - 1876년, 그레이엄 벨이 `전화` 개발 및 특허.
  - 1946년, 최초의 전자식 컴퓨터 `ENIAC` 탄생.
  - 196X년, 컴퓨터 데이터를 전화 신호로 바꿔 주는 `MODEM`의 탄생.
    - 기존에 전화 통신을 위해 설치해 놓은 전화선을 이용하여 멀리 떨어진 두 대의 컴퓨터가 서로 연결됨.
  - 1969년, 인터넷의 시초 `ARPANET`의 탄생.
    - 미 국방성에서 중요 데이터를 보관함에 있어 어느 한 곳이 무너지고 연결이 끊긴다 하더라도, 데이터 소실을 방지할 수 있는 마치 거미줄과도 같이 전체 네트워크를 동기화시키는 작업을 하였다.
    - ARPANET 네트워크는 국방성, 대학, 연구소, 관제시스템, NASA 등으로 점차 확대되어 나갔다.
    - 시간이 지남에 있어 네트워크의 크기는 급격하게 불어나기 시작하였고, 결국 기존 군사 목적의 네트워크는 MILNET이라는 이름으로 따로 빠져 나가고, ARPANET은 민간용 교육 및 연구라는 목적 하에 운영되기 시작했다.
  - 1980년, ARPANET의 본격 활성화에 의해 현대의 `거대 인터넷`으로 변모.

  - ::참고::

    - 전화선은 아날로그 신호인 데에 반해 컴퓨터는 디지털 신호로 설계되었기에 신호 변환기인 모뎀이 필요하였다.

<br>

- ETC

  - 최종적으로 마스터해야 할 것들:

    1. Network
    2. Operating System
    3. Program
    4. Data Structure
    5. Algorithm

<br><br>

##### **_[`| Back to list |`](../../README.md)_**
